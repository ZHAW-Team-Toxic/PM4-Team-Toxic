package com.zhaw.tests;

import static org.junit.jupiter.api.Assertions.*;

import com.badlogic.ashley.core.Engine;
import com.badlogic.ashley.core.Entity;
import com.badlogic.ashley.core.Family;
import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.assets.AssetManager;
import com.badlogic.gdx.files.FileHandle;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.maps.tiled.TiledMapTileLayer;
import com.badlogic.gdx.utils.viewport.ExtendViewport;
import com.zhaw.frontier.components.InventoryComponent;
import com.zhaw.frontier.components.PositionComponent;
import com.zhaw.frontier.components.ResourceProductionComponent;
import com.zhaw.frontier.components.map.BottomLayerComponent;
import com.zhaw.frontier.components.map.MapLayerEnum;
import com.zhaw.frontier.components.map.ResourceTypeEnum;
import com.zhaw.frontier.entityFactories.ResourceBuildingFactory;
import com.zhaw.frontier.systems.BuildingManagerSystem;
import com.zhaw.frontier.systems.MapLoader;
import com.zhaw.frontier.systems.ResourceProductionSystem;
import java.nio.file.Path;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;

/**
 * Test class for the BuildingManagerSystem.
 * Tests the placement of buildings on the map.
 * This test uses the test map:
 * "TMX/frontier_map_for_tests.tmx"
 * It is structured like this:
 * <p>
 * Bottom layer and Resource layer combined:
 * <p>
 * 0,0,1,3,3,3,1,0,0,
 * 0,0,1,1,3,1,1,0,0,
 * 1,1,2,1,1,1,2,1,1,
 * 4,1,1,1,1,1,1,1,5,
 * 4,4,1,1,1,1,1,5,5,
 * 4,1,1,1,1,1,1,1,5,
 * 1,1,2,1,1,1,2,1,1,
 * 0,0,1,1,3,1,1,0,0,
 * 0,0,1,3,3,3,1,0,0
 * <p>
 * Spawn area: 0
 * - Properties on Tile: isBuildable: {false}, isSpawnPoint: {true}, isTraversable: {true}
 * Buildable area: 1
 * - Properties on Tile: isBuildable: {true}, isSpawnPoint: {false}, isTraversable: {true}
 * Water area: 2
 * - Properties on Tile: isBuildable: {false}, isTraversable: {false}
 * Wood resource tile: 3
 * - Properties on Tile: isBuildable: {false}, isTraversable: {true}, resourceType: {wood}
 * Stone resource tile: 4
 * - Properties on Tile: isBuildable: {false}, isTraversable: {true}, resourceType: {stone}
 * Iron resource tile: 5
 * - Properties on Tile: isBuildable: {false}, isTraversable: {true}, resourceType: {iron}
 * <p>
 * Important:
 * - The map is 9x9 tiles.
 * - Tiles are 16 x 16 pixels.
 * - (0,0) is the bottom left corner of the map.
 * - Map gets rendered from bottom left corner.
 */
@ExtendWith(GdxExtension.class)
public class ResourceTrackingSystemTest {

    /** The Ashley engine used for testing. */
    private static Engine testEngine;

    /** The viewport representing the game world. */
    private static ExtendViewport gameWorldView;

    /** The system used to load the test map. */
    private static MapLoader mapLoaderSystem;

    /** The asset manager used to load map assets. */
    private static AssetManager assetManager;

    /** Tile size constant in pixels. */
    private static final int TILE_SIZE = 16;

    /**
     * Sets up the test environment.
     * <p>
     * The test environment is set up by loading the test map and initializing the building manager system.
     * The test asserts that the map is loaded and the bottom layer is initialized.
     * The test also checks if screen conversion works.
     * The test should pass.
     * </p>
     */
    @BeforeAll
    public static void setUp() {
        testEngine = new Engine();

        // Create an OrthographicCamera with world dimensions in pixels.
        OrthographicCamera camera = new OrthographicCamera(9 * TILE_SIZE, 9 * TILE_SIZE);
        // Set camera to y-up.
        camera.setToOrtho(false);

        // Create the viewport with the camera.
        gameWorldView = new ExtendViewport(9 * TILE_SIZE, 9 * TILE_SIZE, camera);
        // Force the screen bounds to start at (0,0) so that unproject interprets (0,0) as bottom left.
        gameWorldView.setScreenBounds(0, 0, 9 * TILE_SIZE, 9 * TILE_SIZE);
        // Update the viewport with screen dimensions (144 x 144) and center the camera.
        gameWorldView.update(9 * TILE_SIZE, 9 * TILE_SIZE, true);
        camera.update();

        try {
            String mapPath = "./testAssets/TMX/frontier_map_for_tests.tmx";
            FileHandle fileHandle = Gdx.files.internal(mapPath);
            // Verify that the map file exists.
            assertTrue(fileHandle.exists(), "Map file should exist");

            mapLoaderSystem = new MapLoader();
            assetManager = new AssetManager();

            // Load the map and finish loading assets.
            mapLoaderSystem.loadMap(assetManager, Path.of(mapPath));
            assetManager.finishLoading();

            // Initialize map layers as entities.
            mapLoaderSystem.initMapLayerEntities(testEngine);
            // Assert that the map is loaded.
            assertNotNull(mapLoaderSystem.getMap(), "Map should be loaded");
            // Assert that the bottom layer component is loaded.
            assertNotNull(
                mapLoaderSystem.getMapEntity().getComponent(BottomLayerComponent.class),
                "Bottom layer should be loaded"
            );

            // Create and add the BuildingManagerSystem.
            BuildingManagerSystem buildingManagerSystem = new BuildingManagerSystem(
                mapLoaderSystem.getMapEntity().getComponent(BottomLayerComponent.class).bottomLayer,
                gameWorldView,
                testEngine
            );
            testEngine.addSystem(buildingManagerSystem);

            // Create and add a stock entity with an InventoryComponent.
            Entity stock = testEngine.createEntity();
            stock.add(new InventoryComponent());
            testEngine.addEntity(stock);

            // Create and add the ResourceProductionSystem.
            ResourceProductionSystem resourceProductionSystem = new ResourceProductionSystem(
                testEngine
            );
            testEngine.addSystem(resourceProductionSystem);
        } catch (Exception e) {
            fail("Failed to load map or initialize systems: " + e.getMessage());
        }
    }

    /**
     * Tests that wood resource production is tracked and collected.
     * <p>
     * A wood resource building is created, positioned at tile (4,2), with a production rate of 1 and a collection range of 1.
     * After updating the system, the inventory should reflect that wood has been collected.
     * </p>
     */
    @Test
    public void testResourceTrackingWood() {
        Entity building = ResourceBuildingFactory.woodResourceBuilding(testEngine);
        // Set building's position.
        building.getComponent(PositionComponent.class).position.set(4, 2);
        // Set production rate for wood.
        building
            .getComponent(ResourceProductionComponent.class)
            .productionRate.put(ResourceTypeEnum.RESOURCE_TYPE_WOOD, 1);

        testEngine.addEntity(building);

        // Update systems.
        testEngine.update(0.1f);

        // Retrieve inventory and assert that wood has been collected.
        InventoryComponent inventory = testEngine
            .getEntitiesFor(Family.all(InventoryComponent.class).get())
            .first()
            .getComponent(InventoryComponent.class);
        int amount = inventory.resources.get(ResourceTypeEnum.RESOURCE_TYPE_WOOD);

        assertTrue(amount > 0, "Wood should be collected");
    }

    /**
     * Tests that stone resource production is tracked and collected.
     * <p>
     * A stone resource building is created, positioned at tile (2,4), with a production rate of 1 and a collection range of 1.
     * After updating the system, the inventory should reflect that stone has been collected.
     * </p>
     */
    @Test
    public void testResourceTrackingStone() {
        Entity building = ResourceBuildingFactory.stoneResourceBuilding(testEngine);
        // Set building's position.
        building.getComponent(PositionComponent.class).position.set(2, 4);
        // Set production rate for stone.
        building
            .getComponent(ResourceProductionComponent.class)
            .productionRate.put(ResourceTypeEnum.RESOURCE_TYPE_STONE, 1);

        testEngine.addEntity(building);

        // Update systems.
        testEngine.update(0.1f);

        // Retrieve inventory and assert that stone has been collected.
        InventoryComponent inventory = testEngine
            .getEntitiesFor(Family.all(InventoryComponent.class).get())
            .first()
            .getComponent(InventoryComponent.class);
        int amount = inventory.resources.get(ResourceTypeEnum.RESOURCE_TYPE_STONE);

        assertTrue(amount > 0, "Stone should be collected");
    }

    /**
     * Tests that iron resource production is tracked and collected.
     * <p>
     * An iron resource building is created, positioned at tile (6,4), with a production rate of 1 and a collection range of 1.
     * After updating the system, the inventory should reflect that iron has been collected.
     * </p>
     */
    @Test
    public void testResourceTrackingIron() {
        Entity building = ResourceBuildingFactory.ironResourceBuilding(testEngine);
        // Set building's position.
        building.getComponent(PositionComponent.class).position.set(6, 4);
        // Set production rate for iron.
        building
            .getComponent(ResourceProductionComponent.class)
            .productionRate.put(ResourceTypeEnum.RESOURCE_TYPE_IRON, 1);

        testEngine.addEntity(building);

        // Update systems.
        testEngine.update(0.1f);

        // Retrieve inventory and assert that iron has been collected.
        InventoryComponent inventory = testEngine
            .getEntitiesFor(Family.all(InventoryComponent.class).get())
            .first()
            .getComponent(InventoryComponent.class);
        int amount = inventory.resources.get(ResourceTypeEnum.RESOURCE_TYPE_IRON);

        assertTrue(amount > 0, "Iron should be collected");
    }

    /**
     * Tests that no wood resource is collected when the production rate is set to 0.
     * <p>
     * A wood resource building is created, positioned at tile (4,4), with a production rate of 0 and a collection range of 1.
     * After updating the system, the inventory should not reflect any wood production.
     * </p>
     */
    @Test
    public void testResourceTrackingWoodShouldNotBeCollected() {
        Entity building = ResourceBuildingFactory.woodResourceBuilding(testEngine);
        // Set building's position.
        building.getComponent(PositionComponent.class).position.set(4, 4);
        // Set production rate for wood to 0.
        building
            .getComponent(ResourceProductionComponent.class)
            .productionRate.put(ResourceTypeEnum.RESOURCE_TYPE_WOOD, 0);

        testEngine.addEntity(building);

        // Update systems.
        testEngine.update(0.1f);

        // Retrieve inventory and assert that no wood has been collected.
        InventoryComponent inventory = testEngine
            .getEntitiesFor(Family.all(InventoryComponent.class).get())
            .first()
            .getComponent(InventoryComponent.class);
        int amount = inventory.resources.get(ResourceTypeEnum.RESOURCE_TYPE_WOOD);

        assertFalse(amount > 0, "Wood should not be collected");
    }

    /**
     * Tears down the test environment by removing all entities and systems,
     * and disposing of the asset manager.
     */
    @AfterAll
    public static void tearDown() {
        testEngine.removeAllEntities();
        testEngine.removeAllSystems();
        assetManager.dispose();
        testEngine = null;
        gameWorldView = null;
        mapLoaderSystem = null;
        assetManager = null;
    }
}
